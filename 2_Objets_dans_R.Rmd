# Objets dans R

## Objectifs et outils

Dans ce chapitre, nous allons :

- introduire la notion d'objet dans R;

- présenter un certain nombre d'entre eux;

- et illustrer avec quelques exemples.

Que nous faudra-t-il?

- R (évidemment)

- RStudio (de préférence)


## La notion d'objet dans R

### Qu'est-ce qu'un objet?

Dans R, un objet représente un concept, une idée.
Il se matérialise par une entité qui possède sa propre identité.
Dans celle-ci, l'on compte deux aspects majeurs: 

- la structure interne;

- le comportement.

Illustrons pour comprendre.
Commençons par créer des objets.

Imaginez que vous voulez créer et conserver des bouts d'information dans R sur les présidents qui se sont succédés à la tête de la République du Mali.
Commençons par le premier président, [Mobido Keïta](https://fr.wikipedia.org/wiki/Modibo_Ke%C3%AFta_(1915-1977)).
Créeons des objects relatifs à son nom et son prénom.

```{r}
nom <- "Keïta"
prenom <- "Mobido"
```

L'acte d'assignation d'une valeur à un objet se fait par le signe `<-` qui est équivalent à `=`.
Chez beaucoup d'utilisateurs, la préférence est donnée à la première.
Ceci peut se comprendre par le fait qu'avec `<-`, l'acte d'assignation se différencie plus facilement d'autres utilisations du signe `=` (dont notamment à l'intérieur de fonctions).
Désormais, ces informations sont stockées dans notre environnement.
Pour vérifier appellons-les!
Ceci revient à les saisir dans notre console et à taper "Entrée"!
```{r}
nom
prenom
```

### Oranges et bananes

Enrichissons notre environnement des objets additionnels.
Ajoutons l'année d'accession au pouvoir.
Appelons cet objet `annee_arrivee_pouvoir`.
```{r}
annee_arrivee_pouvoir <- 1960
```
Comme pour les objets précédent, celui-ci aussi peut être invoqué:
```{r}
annee_arrivee_pouvoir
```
A l'instar de l'orange et de la banane, fort différentes bien que toutes les deux des fruits, ici aussi nos objets diffèrent.
Peut-on les additionner?
```{r, error=c(1)}
nom + annee_arrivee_pouvoir
```
Non, en l'occurence! 
On a un message d'erreur.
R, c'est comme la vraie vie!
Les oranges et les bananes ne se mélangent.

### Ce qui se ressemblent s'assemblent
Les choses qui diffèrent ne s'assemblent pas
Illustration d'une propriété des objets: le comportement.
Regardons les choses qui marchent.
```{r, echo=c(-1, -18)}
1 + 1
```
Maintenant stockons ce résultat dans un objet.
```{r}
objet1 <- 1 + 1
```
Créons-en un autre.
```{r}
objet2 <- 2 + 2
```
Amusons à faire diverses opérations avec ces deux objets
```{r}
objet1 + objet2
objet1 - objet2
objet1 * objet2
objet1 / objet2
```

Bref, vous voyez l'idée!
Les propriétés des objets déterminent les intéractions auxquelles elles se prêtent.
Et ce sont justement ces intéractions qui constituent le coeur de l'analyse de données.
D'où l'importance de la notion d'objet.

### Quelques objets dans R

Dans R, l'on distingue plusieurs types d'objets.
Nous en retiendrons ici 5, qui nous serons utiles tout le long de l'ouvrage.
Il s'agit des:

- caractères (*strings* en anglais);

- nombres (entiers ou réels);

- dates;

- valeurs logiques qui ne prennent que deux valeurs: `TRUE` (vrai) ou `FALSE` (faux);

- facteurs qui sont un format spécial dans R prévu pour les variables catégorielles.

Revenons à notre exemple *présidentiel*!
Nous avons déjà le nom et le prénom...
```{r}
# Caractères
nom <- "Keïta"
prenom <- "Mobido"
```
...ainsi que l'année d'arrivée au pouvoir.
```{r}
# Nombre
annee_arrivee_pouvoir <- 1960
```
Ajoutons la date de naissance,
```{r}
# Date
date_naissance <- as.Date("1915-06-04")
```
une valeur logique indiquant s'il a eu un parcours militaire ou pas,
```{r}
# Valeur logique
parcours_militaire <- FALSE
```
et enfin la région de naissance.
```{r}
# Facteur
region_naissance <- as.factor("Bamako")
```


### La notion de classe et de type

Quand on a faire à des objets dont on ignore l'identité, l'on peut s'appuyer la fonction `class`.
Celle-ci permeet de connaître la classe de l'objet.
La classe est un attribut qui contribue à la formation de l'idée d'un objet.
"Avec quoi se mélange-t-il?"
"A quelles règles de transformation se soumet-il?"
Basiquement, la classe dicte les principes régissant la manipulation de cet objet.
Testons la fonction sur les objets que nous venons de créer pour bien confirmer les identités qu'on leur a attribuées.
```{r}
class(nom)
class(prenom)
class(annee_arrivee_pouvoir)
class(date_naissance)
class(parcours_militaire)
class(region_naissance)
```
Nous voyons que les résultats sont bien conformes aux dénominations que nous leur avons données plus haut.

Dans R, il y a aussi la fonction `typeof` (ou `mode`, mais nous resterons avec la première) qui permet de connaître le mode de stockage d'un objet.
Testons!
```{r}
typeof(nom)
typeof(prenom)
typeof(annee_arrivee_pouvoir)
typeof(date_naissance)
typeof(parcours_militaire)
typeof(region_naissance)
```
Si pour les objets `nom` et `prenom` qui sont des lettres, la classe et le type se confondent, la question est tout autre pour d'autres objets.
Regardons `region_naissance`, par exemple.
En termes de classe, c'est un facteur.
Par contre, en terme de type, R l'a coercé en entier (*integer*).

Les types sont assez génériques car présentant pratiquement les mêmes nomenclatures d'un langage à un autre.
Dans R, nous allons plus nous intéressér aux types suivants:

- logique (*logical*);

- entier (*integer*);

- réel (*double*);

- caractère (*character*);

- liste (*list*);

- valeur nulle (*NULL*).

Les objets que nous avons vus là peuvent être pensés comme des briques.
Ils entrent à leur tour dans la formation d'autres objets qui varient les uns des autres.
Tout comme les constructions peuvent différer entre elles.

### Vers d'autres types d'objets

La deuxième catégorie d'objets que nous allons voir ici peuvent être pensés comme des objets composites.
Nous en verrons quatre types:

- le vecteur;

- la matrice;

- le *data frame* (cadre de données ou données rectangulaires);

- la liste.

## Vecteurs

### Qu'est-ce qu'un vecteur?

De façon très simple, un vecteur est un ensemble d'éléments de même nature.
Revenons à notre exemple pour mieux comprendre.
Nous avons défini l'objet `nom`, n'est-ce pas?
Est-ce un vecteur?
A quoi peut-on voir si c'est un vecteur ou pas?
La réponse:
```{r}
is.vector(nom)
```
Donc nous avons crééé des vecteurs depuis longtemps et on voit qu'un objet d'un seul élément peut être un vecteur.
Maintenant, compte le nombre d'éléments que compte ce vecteur.
```{r}
length(nom)
```
C'est vraiment un singleton qu'on a là...pour le moment! 

### Créons-en, des vecteurs!

Décidons d'étendre nos observations à tous les présidents de la République du Mali.
En voici de quoi nous faire revisiter nos livres d'histoire...ou juste visiter Wikipedia!

```{r}
# Omettons les périodes de transition (la valeur pédagogique est ce qui est recherché ici!)
nom <- c("Keïta", "Traoré", "Konaré", "Touré", "Keïta")
prenom <- c("Modibo", "Moussa", "Alpha Oumar", "Amadou Toumani", "Ibrahim Boubacar")
date_naissance <- as.Date(c("1915-06-04", "1936-09-25", "1946-02-02", "1948-11-04", "1945-01-29"))
region_naissance <- as.factor(c("Bamako", "Kayes", "Kayes", "Mopti", "Koutiala"))
annee_arrivee_pouvoir <- c(1960, 1968, 1992, 2002, 2013)
parcours_militaire <- c(FALSE, TRUE, FALSE, TRUE, FALSE)
```
Maintenant, expérimentons!
Commençons avec `nom` que nous avons écrasé avec de nouvelles valeurs.
```{r}
is.vector(nom)
length(nom)
class(nom)
typeof(nom)
```

"nom" est un **vecteur**, un ensemble de **5** éléments en **charactères**.
Amusez-vous à expérimenter avec les autres vecteurs.

### Vrai pour un, vrai pour plusieurs

Vous vous rappelez que plus haut, nous voyions que les opérations n'étaient pas possible entre de différentes natures.
Et bien, cette règle, valable à l'échelle des objets élémentaires, l'est aussi aux échelles supérieures.

Prenons nos données et cherchons à déterminer l'âge des présidents à leur arrivée au pouvoir.
On a les éléments nécéssaires pour ce faire, la date de naissance et l'année d'arrivée au pouvoir.
Toutefois, ces deux vecteurs ne sont pas de même nature.
```{r, error=c(1)}
age_arrivee_pouvoir <- annee_arrivee_pouvoir - date_naissance
```
On a un message d'erreur.
Apparemment l'opération n'est pas possible.
Il faudrait procéder à une transformation: déduire de la date de naissance l'année pour conduire l'opération avec celle-ci.
```{r}
annee_naissance <- as.numeric(format(date_naissance,'%Y'))
```
Testons si le nouveau vecteur est de même nature de celui de `annee_arrivee_pouvoir`.
```{r}
class(annee_naissance)
```
Maintenant, nous pouvons procéder à l'opération
```{r}
age_arrivee_pouvoir <- annee_arrivee_pouvoir - annee_naissance
age_arrivee_pouvoir
```
On le confirme: les oranges et les bananes ne se mélangent pas.
Toutefois, R nous fait souvent des cocktails de fruits en coerçant certains éléments.
Imaginons que l'on veuille rassembler le prénom et le nom dans un seul vecteur.
Collons avec une fonction de base dans R, `paste`, (ne vous en faites pas, vous ferez progressivement connaissance avec les fonctions!)
```{r}
prenom_nom <- paste(prenom, nom)
prenom_nom
```
On peut être enclin à dire que ceci est passé sans souci parce que `nom` et `prenom` sont tous les deux des vecteurs en caractères.
Maintenant, et si l'on ajoutait l'année d'arrivée au pouvoir?
```{r}
prenom_nom_age <- paste(prenom, nom, ",", age_arrivee_pouvoir)
prenom_nom_age
```
C'est passé comme une lettre à la poste (pour la génération email, voici ce qu'est [la poste](https://fr.wikipedia.org/wiki/Poste)).
Car R a une hiérarchie entre les objets.
Avant de déclarer forfait avec un message d'erreur, il tente tant bien que mal d'exécuter l'opération.
Sur la base de cette hiérarchie, il coerce certains éléments à se conformer à d'autres, partant du plus flexible au moins flexible: `logique` < `entier` < `réel` < `caractère`.
Pour comprendre ça, créons un vecteur de valeurs logiques.
```{r}
vecteur_logique <- c(TRUE, FALSE)
```
Confirmons sa classe.
```{r}
class(vecteur_logique)
```
Ajoutons un troisième élément qui sera un entier. Disons 1.
```{r}
vecteur_entier <- c(vecteur_logique, 1)
```
Qu'obtenons-nous?
```{r}
vecteur_entier
```
Des entiers!
R a coercé `TRUE` en 1 et `FALSE` en 0.
```{r}
class(vecteur_entier)
```
Ajoutons un quatrième élément, cette fois-ci une réel: 2.5 (dans R, comme en anglais, les décimales viennent après un `.`, pas une `,`, qui sert plutôt de séparateur de milliers).
```{r}
vecteur_reel <- c(vecteur_entier, 2.5)
vecteur_reel
class(vecteur_reel)
```
La mutation se voit au fait que R a affecté aux trois premiers éléments des décimales, bien qu'initialement c'étaient des entiers.
Maintenant, ajoutons un cinquième élément: un prénom.
```{r}
vecteur_caractere <- c(vecteur_reel, "Mariam")
vecteur_caractere
class(vecteur_caractere)
```
Là aussi, la coercion se voit.

### Nommer les éléments d'un vecteur

Jusque là, ce sont des objets à part intégrale que nous avons nommés.
On les a assignés des noms pour les garder dans notre environnement de travail.
Maintenant, nous allons donner un nom aux éléments de vecteur.
Dressons l'analogie suivante.
Notre environnement dans R est comme une rue.
Dans celle-ci, nous avons des concessions dont les portes sont toutes numérotées: ce sont les noms des objets.
A l'intérieur des concessions, nous avons des individus: ce sont les éléments à l'intérieur de nos objets.
Tout comme ces individus portent des prénoms, nous pouvons donner des appélations aux éléments contenus dans nos objets.

Considerons que nous voulons associer à chaque date de naissance le nom du président en question.
```{r}
names(date_naissance) <- prenom_nom
```
Voyons ce que ça donne
```{r}
date_naissance
```
C'est beau non!
Il est intéréssant de noter que quand on conduit des opérations sur des vecteurs aux éléments nommés, le résultat peut hériter de ces propriétés.
Reprenons l'opération de déduction de l'âge à l'arrivée au pouvoir.
Rappelons les deux vecteurs.
```{r}
annee_naissance
annee_arrivee_pouvoir
```
Nommons juste un des deux vecteurs.
```{r}
names(annee_naissance) <- prenom_nom
annee_naissance
```
Procédons à l'opération.
```{r}
age_arrivee_pouvoir <- annee_arrivee_pouvoir - annee_naissance
age_arrivee_pouvoir
```
Le vecteur `age_arrivee_pouvoir` a hérité des noms d'éléments.

Cette règle n'est pas toutefois immuable.
Quand les éléments sont coercés à prendre une autre classe que leur classe de départ, ils peuvent perdre leur nom, qui n'est qu'un de leurs attributs (qui sont subordonnés à leur classe).
Reprenons la déduction de l'année de naissance à partir de la date de naissance.
```{r}
annee_naissance <- format(date_naissance,'%Y')
annee_naissance
class(annee_naissance)
```
Ici, l'année n'a pas été coercé.
Elle a été extraite par la fonction sous format de caractères.
En voulant conformer le vecteur à la classe de nombre (on descend dans la hiérarchie), on coerce les éléments.
```{r}
annee_naissance <- as.numeric(format(date_naissance,'%Y'))
annee_naissance
class(annee_naissance)
```
Avec la coercion, les noms se perdent.
Il est donc utile de se rappeler que les noms d'éléments ne sont pas immunes à la coercion.
Toutefois, quand les opérations se passent entre des éléments de même nature, les noms sont bien saufs!

### Opérations sur vecteurs

#### Sélection explicite

Il arrive souvent qu'on ne soit intéréssée que par un élément précis d'un vecteur.
Peut-être l'on souhaite connaître seulement l'âge du premier président lors de son accès au pouvoir. 
C'est le premier élément du vecteur `age_arrivee_pouvoir`.
```{r}
age_arrivee_pouvoir[1]
```
Peut-être nous voulons l'information pour le 1er et le 3ème présidents.
Ce sont les 1er et 3ème éléments du vecteur.
```{r}
age_arrivee_pouvoir[c(1, 3)]
```
Peut-être que nous voulons l'information du 1er au 3ème président.
```{r}
age_arrivee_pouvoir[c(1:3)]
```
On peut aussi souhaiter exclure certains éléments.
Imaginons que l'on veuille seulement regarder les informations sans les deux derniers éléments du vecteur.
```{r}
age_arrivee_pouvoir[-c(4, 5)]
```
Le signe `[]` agit comme une porte d'entrée à l'intérieur du vecteur tandis que les chiffres indiqués sont des index qui indiquent les éléments intérêt.
L'opération peut consister en une sélection ou une exclusion selon que l'opérateur `c` est précédé du signe `-` (exclusion) ou pas (sélection).

#### Sélection à partir de logiques

La sélection à l'intérieur d'un vecteur peut aussi se faire à partir de valeurs logiques.
L'on peut poser des critères auxquels certains éléments répondraient.
Et sur la base de leur confirmité au(x) critère(s) posé(s), l'on pourra effectuer la sélection (ou l'exclusion).
Cette fonctionnalité est très utile le data scientist d'utiliser les questions qu'il se pose pour avoir un aperçu des données qui sont à sa disposition.

Explorons la question suivante: quels sont les présidents arrivés au pouvoir avant l'âge de 50 ans?

```{r}
president_avant_50ans <- age_arrivee_pouvoir < 50
president_avant_50ans
```
On transforme maintenant ce vecteur de valeurs logiques en outil de sélection.
On peut soir regarder le nom de ses présidents:
```{r}
prenom_nom[president_avant_50ans]
```
Le résultat nous donne le nom des présidents pour lesquels le vecteur de valeurs logiques affiche `TRUE`.
On peut utiliser le même critère sur d'autres vecteurs.
Voyons le vecteur d'âge d'arrivée au pouvoir: quel âge avec les présidents qui sont arrivés au pouvoir avant l'âge de 50 ans?
```{r}
age_arrivee_pouvoir[age_arrivee_pouvoir < 50]
```
Pendant qu'on y est, dans quelle région sont-ils nés?
```{r}
names(region_naissance) <- prenom_nom # nommons d'abord les éléments
region_naissance[age_arrivee_pouvoir < 50]
```
Vous comprenez la logique.

#### Statistiques sommaires

Une fois le vecteur constitué, il peut en lui-même faire l'objet d'opérations diverses.
Posons diverses questions avec le vecteur `age_arrivee_pouvoir`.
Quelle est la moyenne d'âge d'arrivée au pouvoir sur la base des éléments disponibles?
```{r}
mean(age_arrivee_pouvoir)
# une alternative donnat le même résultat.
sum(age_arrivee_pouvoir)/length(age_arrivee_pouvoir)
```
Quel est l'âge d'arrivée au pouvoir le plus bas ?
```{r}
min(age_arrivee_pouvoir)
```
Quel est l'âge d'arrivée au pouvoir le plus élevé ?
```{r, echo=c(-1, -12)}
max(age_arrivee_pouvoir)
```

#### Ajustement et recyclage

Maintenant, revenons-en un peu aux opérations entre deux vecteurs.
Imaginez maintenant, que l'on veuille connaître l'âge auquel les présidents ont quitté le pouvoir.
Rappellons d'abord le vecteur `age_arrivee_pouvoir` que nous avions déjà généré.
```{r}
age_arrivee_pouvoir
```
Construisons ensuite un vecteur avec le nombre d'années passées au pouvoir.
```{r}
annee_en_pouvoir <- c(8, 23, 10, 10)
```
Maintenant calculons l'année de départ du pouvoir en ajoutant à l'âge d'arrivée au pouvoir le nombre d'années qui y ont été passé.
```{r}
age_depart_pouvoir <- age_arrivee_pouvoir + annee_en_pouvoir
age_depart_pouvoir
```
Parvenez-vous à décéler l'erreur?
Nous avons additionné une vecteur de 5 éléments, `age_arrivee_pouvoir`, avec un vecteur de 4 éléments `annee_en_pouvoir`.
R a recyclé le premier élément du vecteur court (4) pour poursuivre l'opération d'addition entre les deux vecteur et l'a ajouté au 5ème élément du vecteur long.
D'où la valeur de `76`.
```{r}
68 + 8
```
R avertit, mais conduit l'opération.
De ce fait, même si les opérations entre les vecteurs de même nature s'exécute sans problème majeur, il reste utile de vérifier leur longueur.
Pour éviter le recyclage, il faudrait ne pas laisser de videe dans le vecteur court, s'assurer que les vecteurs impliqués dans l'opératio sont de la même taille.
Sur nos 5 présidents, nous n'avons pas ajouté le nombre d'années passées au pouvoir (car le mandat est encore en cours pendant la rédaction du présent document).
Une solution serait de remplir la position dans le vecteur avec la valeur `NA`, indiquant un valeur manquante.
Ajoutons-le à è ``
```{r}
annee_en_pouvoir <- c(annee_en_pouvoir, NA)
annee_en_pouvoir
```
Reprenons l'opération.
```{r}
age_depart_pouvoir <- age_arrivee_pouvoir + annee_en_pouvoir
age_depart_pouvoir
```
Ne sachant pas comment faire l'opération pour la dernière entrée du vecteur car l'un des composante est `NA`, R reconduit cette valeur.
Ainsi le recyclage est évité.

## Matrices

### La matrice, un ensemble de vecteurs

De façon basique, une matrice n'est autre qu'une collection de vecteurs.
De ce fait, elle hérite d'une propriété fondamentale du vecteur: ne peuvent former une matrice que des éléments de même nature.

Retournons à notre exemple.
Associons les noms et prénoms en une matrice car tous deux sont en charactères.

Solution 1: coller horizontalement les deux vecteurs
```{r}
prenom_nom_hmatrix <- rbind(prenom, nom)
prenom_nom_hmatrix
```
Solution 2: coller verticalement les deux vecteurs
```{r}
prenom_nom_vmatrix <- cbind(prenom, nom)
prenom_nom_vmatrix
```
On voit que la matrice hérite des noms donnés aux différents vecteurs.

Bien que l'on puisse créer une matrice en combinant différents vecteurs, horizontalement avec `rbind` ou verticalement avec `cbind`, il existe aussi une fonction qui permet de créer directement une matrice: `matrix`.
Il est toutefois utile de connaitre l'ordre de positionnement des éléments.
Reprenons la création avec `matrix`, horizontalement...
```{r, echo=c(-1, -10)}
knitr::asis_output("\\tiny")
prenom_nom_hmatrix <- matrix(c("Modibo", "Moussa", "Alpha Oumar", "Amadou Toumani", "Ibrahim Boubacar",
                             "Keïta",  "Traoré", "Konaré", "Touré", "Keïta"),
                             byrow = TRUE,
                             nrow = 2,
                             dimnames = list(c("prenom", "nom"), NULL)
                             )
prenom_nom_hmatrix
```
...et verticalement
```{r}
prenom_nom_vmatrix <- matrix(c("Modibo", "Keïta",
                               "Moussa", "Traoré",
                               "Alpha Oumar", "Konaré", 
                               "Amadou Toumani", "Touré", 
                               "Ibrahim Boubacar", "Keïta"),
                             byrow = TRUE,
                             ncol = 2,
                             dimnames = list(NULL, c("prenom", "nom"))
                             )
prenom_nom_vmatrix
```
Dans la fonction `matrix`, les arguments `nrow`, `ncol`, `byrow` et `bycol` servent à celà.
Fonction, arguments...ne vous en faites pas! 
On y viendra.

### La matrice, un objet bidimensionnel

La matrice n'est pas seulement un ensemble de vecteurs.
Elle se distingue aussi de par sa bidimensionnalité.
Pendant que le vecteur est soit une ligne de plusieurs éléments (1 x n) soit une colonne de plusieurs éléments éléments (n x 1), la matrice, elle, est faite de plusieurs lignes (n rows) et de plusieurs colonnes (n columns).
Ici n étant bien sûr supérieur à 1.
Nous avions noté que pour connaître le nombre d'éléments dans un vecteur on utilisait la fonction `length`.
```{r}
length(prenom_nom)
```
La même chose marche-t-elle pour le vecteur?
```{r}
length(prenom_nom_vmatrix)
```
En l'occurence, non!
`length` ne rend pas compte de la bidimensionnalité.
Il y a une autre fonction pour ça: `dim`.
```{r}
dim(prenom_nom_vmatrix)
```
La bidimensionnalité se lit aussi dans le nom des rangées.
```{r}
dimnames(prenom_nom_vmatrix)
```
Comme nous avons vu plus haut, l'on peut nommer les rangées depuis la création de la matrice.
Reprenons la création de `prenom_nom_vmatrix` en nommant toutes les rangées, aussi bien horizontales que verticales.
```{r}
prenom_nom_vmatrix <- matrix(c("Modibo", "Keïta",
                               "Moussa", "Traoré",
                               "Alpha Oumar", "Konaré", 
                               "Amadou Toumani", "Touré", 
                               "Ibrahim Boubacar", "Keïta"),
                             byrow = TRUE,
                             ncol = 2,
                             dimnames = list(c("1er", "2ème", "3ème", "4ème", "5ème"), 
                                             c("prenom", "nom"))
                             )
```
Imprimons la matrice.
```{r}
print(prenom_nom_vmatrix)
```
Examinons la matrice à travers différentes fonctions que nous avons vues en haut:

- la dimension, c'est-à-dire le nombre de lignes et le nombre de colonnes; 
```{r}
dim(prenom_nom_vmatrix)
```
- les noms des lignes et des colonnes;
```{r}
dimnames(prenom_nom_vmatrix)
```
- le nombre de lignes uniquement;
```{r}
nrow(prenom_nom_vmatrix)
```
- le nom des lignes uniquement;
```{r}
rownames(prenom_nom_vmatrix)
```
- le nombre de colonnes uniquement;
```{r}
ncol(prenom_nom_vmatrix)
```
- le nom des colonnes uniquements.
```{r}
colnames(prenom_nom_vmatrix)

```

### Opérations sur matrices

#### Une autre matrice

A l'instar des vecteurs, les matrices se prêtent elles aussi à une variété d'opérations.
Explorons-en quelques unes.

Reprenons notre exemple sur les présidents maliens et considérons les années d'évènements majeurs: naissance, arrivée au pouvoir et départ du pouvoir.
```{r}
annee_evenement_matrix <- matrix(c(1915, 1936, 1946, 1948, 1945,
                                   1960, 1968, 1992, 2002, 2013,
                                   1968, 1991, 2002, 2012, NA),
                                 byrow = TRUE,
                                 ncol = 5,
                                 dimnames = list(c("Naissance", "Arrivée", "Départ"),
                                                 c("M. Keïta", "M. Traoré", "A.O. Konaré", "A.T. Touré", "I.B. Keïta")))
annee_evenement_matrix
```


#### Questions logiques

Maintenant que nous avons notre matrice, amusons-nous avec.
Prenons un grand-père née vers 1949 (oui, il fait partie des *né vers*), marié à l'âge de 22 ans, père 1 an plus tard, grand-père 18 ans plus tard et décédé à l'âge de 61 ans.
Quels sont les évènements qui se sont passés de son vivant?
```{r}
ce_que_grandpa_a_vu <- annee_evenement_matrix > 1949 & annee_evenement_matrix < (1949 + 61)
ce_que_grandpa_a_vu
```
Apparemment, il en a vu beaucoup, mais tous les présidents le dépassent en âge.
On vient d'introduire ici la notion d'addition dans les critères (dans le prochain chapitre, la question sera plus développée).

#### Extraction par position

Comme pour les vecteurs, des éléments peuvent être explicitement sélectionnés à l'intérieur des matrices.
Comme pour ceux-ci également, le signe `[]` peut être utilisé.
Revenons à notre matrice `annee_evenement_matrix`.
```{r}
annee_evenement_matrix
```
Supposons que l'on veuille connaître l'élément qui est dans la cellule de la 3ème ligne et le 2ème colonne.
```{r}
annee_evenement_matrix[3, 2]
```
Ou la 3ème ligne toute entière.
```{r}
annee_evenement_matrix[3, ]
```
Ou la 2ème colonne toute entière.
```{r}
annee_evenement_matrix[ , 2]
```
Avec les matrices, l'on spécifie deux éléments à l'intérieur des crochets.
Le premier désigne la ligne à sélectionner et le deuxième la colonne.

#### Extraction par nom

Si les rangées sont nommés, alors il est aussi possible de passer par ces noms pour les sélectionner.
Vous vous rappelez `rownames` ou `colnames`?
Si la réponse est non, je saurai que vous n'avez pas tout suivi!
Passons par ces fonctions pour sélectionner des lignes et colonnes d'intérêt dans notre matrice.
```{r}
rownames(annee_evenement_matrix)
colnames(annee_evenement_matrix)
```
Séléctionnons la ligne relative aux années de naissance.
```{r}
annee_evenement_matrix[rownames(annee_evenement_matrix) == "Naissance", ]
```
Et cherchons les éléments concernant le président Modibo Keïta.
```{r}
annee_evenement_matrix[, colnames(annee_evenement_matrix) == "M. Keïta"]

```

#### Consolidation

Il arrive souvent que l'on souhaite consolider une matrice en y ajoutant de nouvelles informations.
Ces nouvelles informations peuvent même être dérivées d'éléments déjà existants à l'intérieur de la matrice.
Considérons ici que nous voulions ajouter à notre matrice l'âge à l'arrivée au pouvoir et l'âge au départ du pouvoir.
Nous passons tout simplement par les techniques que nous avons déjà vues pour générer ces nouveaux ééments.
```{r}
# Un vecteur pour l'âge d'arrivée au pouvoir
age_arrivee_pouvoir <- 
  annee_evenement_matrix[rownames(annee_evenement_matrix) == "Arrivée", ] - 
  annee_evenement_matrix[rownames(annee_evenement_matrix) == "Naissance", ]
# Un vecteur pour l'age de départ du pouvoir
age_depart_pouvoir <- 
  annee_evenement_matrix[rownames(annee_evenement_matrix) == "Départ", ] - 
  annee_evenement_matrix[rownames(annee_evenement_matrix) == "Naissance", ]
```

# Ajoutons maintenant c'est deux nouveaux vecteurs à notre matrice
annee_evenement_matrix_cons <- rbind(annee_evenement_matrix, 
                                     "Âge d'arrivée au pouvoir" =  age_arrivee_pouvoir, 
                                     "Âge de départ du pouvoir" = age_depart_pouvoir)
# Voyons la matrice
annee_evenement_matrix_cons
# Nous sommes passés par la fonction "rbind()". Sachez qu'il y a plusieurs solutions!
# Remarquez-vous "NA" dans une nouvelle cellule? Pouvez-vous expliquer pourquoi?



### Opérations sur matrices: calculs

```{r, echo=c(-1, -13)}
knitr::asis_output("\\tiny")
# Comme pour les vecteurs, des calculs sont possibles sur les matrices.
# Pour ce faire, limitons-nous à deux informations de la matrice: les âges.
# Ajoutons aussi la durée de la période passée au pouvoir.
age_pouvoir_matrix <- rbind(annee_evenement_matrix_cons[c(4, 5),],
                            "Durée au pouvoir" = annee_evenement_matrix_cons[5, ] - 
                              annee_evenement_matrix_cons[4, ])
age_pouvoir_matrix[, -c(1)] # -c(1): juste pour une commodité d'impression.
# Calculons la moyenne pour chacune des lignes (âges moyens, durées moyennes)
rowMeans(age_pouvoir_matrix)
# On voit des "NA". R ne traite pas les valeurs inconnues de lui-même. On lui instruit de les ignorer.
rowMeans(age_pouvoir_matrix, na.rm = TRUE)
# Comme pour beaucoup de fonctions dans R, tout ce qu'il y avec "row" existe avec "col" 
# Testez les fonctions suivantes: colSums(), rowSums(), colMeans() et rowMeans().
knitr::asis_output("\\normalsize")
```


## _Data frames_

### Le *data frame*, au-délà de la matrice (1)

```{r, echo=c(-1, -c(10:19), -23)}
knitr::asis_output("\\tiny")
# Jusque là, nous avons travaillé avec des éléments de même nature.
# Et pourtant le data scientist ne peut pleinement mener ses
# ses investigations avec une telle contrainte.
# Il a besoin d'explorer en même temps des informations de diverses natures.
# D'où le data frame. Qu'est-ce que c'est au juste?
# Un format d'organisation de données en forme rectangulaire.
# Toutefois, contrairement à la matrice, elle respecte la nature des données qu'elle contient.
# Explorons l'idée. Rassemblons verticalement les différents vecteurs que nous avons crééés
# echo = FALSE - début
rm(list = ls())
nom <- c("Keïta", "Traoré", "Konaré", "Touré", "Keïta")
prenom <- c("Modibo", "Moussa", "Alpha Oumar", "Amadou Toumani", "Ibrahim Boubacar")
date_naissance <- as.Date(c("1915-06-04", "1936-09-25", "1946-02-02", "1948-11-04", "1945-01-29"))
region_naissance <- as.factor(c("Bamako", "Kayes", "Kayes", "Mopti", "Koutiala"))
annee_arrivee_pouvoir <- c(1960, 1968, 1992, 2002, 2013)
annee_en_pouvoir <- c(8, 23, 10, 10, NA)
parcours_militaire <- c(FALSE, TRUE, FALSE, TRUE, FALSE)
# echo = FALSE - fin
presidents_df <- cbind(nom,
                      prenom,
                      date_naissance,
                      region_naissance,
                      parcours_militaire,
                      annee_arrivee_pouvoir,
                      annee_en_pouvoir)
# Qu'est-ce que ça donne?
presidents_df
knitr::asis_output("\\normalsize")
```

### Le *data frame*, au-délà de la matrice (2)

```{r, echo=c(-1, -10)}
knitr::asis_output("\\tiny")
# Nous avons vu que certaines informations ont été dénaturées.
# Certaines données ont été coercées à se transformer en autre chose
# Regardons la classe de l'objet "presidents_df"
class(presidents_df)
typeof(presidents_df)
# Les vecteurs ont été rassemblés en matrice (class)
# Les éléments ont toutefois été coercés en charactères (typeof)
# C'est en celà que le data frame révèle sa place.
knitr::asis_output("\\normalsize")
```

### Le *data frame*, au-délà de la matrice (3)

```{r, echo=c(-1, -8)}
knitr::asis_output("\\tiny")
# Reprenons l'opération
presidents_df <- data.frame(nom,
                            prenom, 
                            date_naissance, 
                            region_naissance, 
                            parcours_militaire, 
                            annee_arrivee_pouvoir, 
                            annee_en_pouvoir,
                            stringsAsFactors = FALSE)
# Regardons à nouveau
presidents_df
# Qu'en est-il de la classe et du type
class(presidents_df)
knitr::asis_output("\\normalsize")
```

### Le *data frame*, au-délà de la matrice (4)

```{r, echo=c(-1, -17)}
knitr::asis_output("\\tiny")
# Maintenant que nous savons à quoi ressemble un data frame, essayons de le définir.
# Un data frame est une forme d'organisation de données en format rectangulaire où
# les lignes sont des observations et les colonnes des attributs de ceux-ci.
# Ici par exemple, nous organisons diverses informations sur les individus qui
# ont assumé le poste de Président de la République du Mali.
# Chaque ligne sera dédiée à un président et rassemblera tous les informations sur lui (attributs).
# Chaque colonne sera dédiée à un seul attribut et couvrira tous les présidents (observations).
# Introduisons ici la fonction "str" qui permet de visualiser la structure d'un objet dans R
# Elle permettra de rendre compte de toute la richesse du concept de data frame.
str(presidents_df)
# On a une synthèse: nombre d'observations et nombre de variables - comme avec la fonction dim().
# On voit aussi que pour chaque variable, on a :
# - le nom
# - la classe
# - quelques observations
knitr::asis_output("\\normalsize")
```

### Opérations sur _data frame_: sélection de cellules

```{r, echo=c(-1, -10)}
knitr::asis_output("\\tiny")
# En matière de sélection, la data frame hérite beaucoup de la matrice.
# Les principes demeurent
# Si l'on veut la ligne 2 de la colonne 4, on fait:
presidents_df[2, 4]
# Si l'on veut la ligne 5 (un président, une observation)
presidents_df[2, ]
# Ou encore la colonne 4 (une variable, un attribut)
presidents_df[, 4]
knitr::asis_output("\\normalsize")
```

### Opérations sur _data frame_: sélection de variables

```{r, echo=c(-1, -9)}
knitr::asis_output("\\tiny")
# Comme pour la matrice, avec le data frame, on peut utiliser le nom des colonnes (variables) 
# pour accéder aux éléments. Regardons juste la variable "date_naissance".
presidents_df[, "date_naissance"]
# Le data frame offre en plus une alternative: les variables y sont accessibles avec le signe "$".
presidents_df$date_naissance
# Cependant, la première solution se prête à la sélection de plusieurs variables.
presidents_df[, c("date_naissance", "region_naissance")]
knitr::asis_output("\\normalsize")
```

### Opérations sur _data frame_: création de variables

```{r, echo=c(-1, -14)}
knitr::asis_output("\\tiny")
# Comme avec les matrices, souvent, l'analyse peut souhaiter ajouter une nouvelle variable à son data frame.
# Procédons comme avec les matrices à la génération de deux nouvelles variables:
# l'âge d'arrivée au pouvoir et l'âge de départ du pouvoir.
# Pour commencer, générons l'année de naissance
presidents_df$annee_naissance <- as.numeric(format(presidents_df$date_naissance,'%Y'))
# Ensuite on génère l'âge d'arrivée au pouvoir
presidents_df$age_arrivee_pouvoir <- presidents_df$annee_arrivee_pouvoir - presidents_df$annee_naissance
# Ensuite l'âge de départ du pouvoir
presidents_df$age_depart_pouvoir <- presidents_df$age_arrivee_pouvoir + presidents_df$annee_en_pouvoir
# Regardons notre nouveau data frame
str(presidents_df)
# A travers cette création, on voit comment on peut mener des opérations entre des colonnes d'un data frame.
knitr::asis_output("\\normalsize")
```

### Opérations sur _data frame_: suppression de variables

```{r, echo=c(-1, -10)}
knitr::asis_output("\\tiny")
# Dans notre exemple, nous avons crééé l'année de naissance comme étape transitoire vers une 
# autre variable. Sachant que nous avons la même information dans la date de naissance, 
# l'on peut éviter la redondance, donc la supprimer.
# Comment s'y prend-on dans R?
presidents_df$annee_naissance <- NULL
# Vérifions si cette colonne est partie.
str(presidents_df)
# Mission accomplie!
knitr::asis_output("\\normalsize")
```

### Opérations sur _data frame_: sélection d'observations

```{r, echo=c(-1, -13)}
knitr::asis_output("\\tiny")
# Nous avons vu que comme la matrice, les éléments du data frame sont accessibles grâce aux numéros de lignes.
# Ici, nous allons voir qu'il est aussi possible de passer par des critères spécifiques aux variables
# pour sélectionner des observations.
# Cherchons seulement la date de naissance des présidents nés dans la région de "Kayes".
presidents_df[presidents_df$region_naissance == "Kayes", c("nom", "prenom")]
# Il est possible d'aboutir au même résultat avec une fonction intégrée à R: "subset"
# Expérimentons
subset(x = presidents_df, subset = region_naissance == "Kayes", select = c(nom, prenom))
# Vous voyez? 
# Avec R, tous les chemins mènent...à Roundé.
# (Rome est trop loin pour moi! Même s'il comment par R).
knitr::asis_output("\\normalsize")
```

### Opérations sur _data frame_: ordonner les observations

```{r, echo=c(-1, -8)}
knitr::asis_output("\\tiny")
# On peut souvent souhaiter  ordonner son data frame selon une variable donnée.
# Rearrangeons nos données selon l'année de naissance des présidents
ordre_age <- order(presidents_df$date_naissance)
ordre_age
# A l'aide de ce classement, regardons les nom, prénom et date de naissance
presidents_df[ordre_age, c("nom", "prenom", "date_naissance")]
knitr::asis_output("\\normalsize")
```

### _Data frame_: le meilleur reste à venir

Le _data frame_ est la pièce maîtresse de l'analyse dans [\textcolor{blue}{R}](http://r-project.org), comme dans beaucoup d'autres langages.
D'ailleurs, d'autres langages ont développé des concepts similaires.
En prenant [\textcolor{blue}{Python}](https://www.python.org/) par exemple, on trouve la notion de *DataFrame*, une adaption du concept de *data frame* tel que défini dans R.
Pour dire combien l'idée englobée dans le *data frame* est puissante.
D'où son rôle capital dans le reste de ce cours.

C'est avec le *data frame* que nous:

- procéderons à des manipulations de données: du nettoyage à la transformation ;

- explorerons des données par la visualisation ;

- introduirons l'application de modèles à des données.

## Listes

### Les listes, que faire de l'ordre et de la structure?
```{r, echo=c(-1, -19)}
knitr::asis_output("\\tiny")
# La liste (list en anglais et dans R) apporte elle aussi sa particularité.
# Elle permet de créer un espace pour les données non structurées dans R
# Créons de nouveaux éléments
# Commençons par les pays voisins du Mali: un vecteur en caractères
voisins_vec_char <- c( "Algérie", "Burkina-Faso", "Côte d'Ivoire", "Guinée", "Mauritanie", "Niger", "Sénégal")
# Ajoutons des données sur le population (à partir de 1976, 1987, 1998 et 2009)
# ça nous fait une matrice en nombres (entiers).
population_matrix_int <- matrix(data = c(3123733, 3269185, 6392918, 
                                         3760711, 3935638, 7696349,
                                         4856023, 4954889, 9810912,
                                         7204990, 7323672, 14528662),
                                byrow = TRUE,
                                nrow = 4,
                                dimnames = list(c(1976, 1987, 1998, 2009), 
                                                c("Hommes", "Femmes", "Total")))
# Ajoutons un dernier élément: lesquels de nos présidents sont encore vivants?
# Mettons ça sous forme boléén.
presidents_en_vie_vec_logi <- c(FALSE, TRUE, TRUE, TRUE, TRUE)

# Nous avons là un beau monde. Rassemblons tout ça dans une liste!
mali_list <- list(presidents = presidents_df,
                  voisins = voisins_vec_char,
                  population = population_matrix_int,
                  presidents_en_vie = presidents_en_vie_vec_logi)
# De par leurs différences en nature, forme et taille, rien ne prédispose ses objets à être contenus
# dans le même objet! Et pourtant ça tient dans notre liste.
# Explorons-là!
knitr::asis_output("\\normalsize")
```

### Listes, un contenant de contenants (1)

```{r, echo=c(-1, -19)}
knitr::asis_output("\\tiny")
# Commençons par la structure de la liste. Que voit-on?
str(mali_list)
# Qu'en est-il des noms
names(mali_list)
# Les noms assignés aux objets sont bien reconduits
# Voyons voir si à l'instar des matrices et des data frames, ces noms peuvent être utilisés
# pour accéder aux éléments qui y sont stockés.
knitr::asis_output("\\normalsize")
```


### Listes, un contenant de contenants (2)

```{r, echo=c(-1, -9)}
knitr::asis_output("\\tiny")
# Prenons le vecteur sur les pays voisins.
mali_list[["voisins"]]
# Le même résultat doit être possible par l'ordre de l'objet dans la liste, le 2ème.
mali_list[[2]]
# Peut-on utiliser le signe "$" comme avec les data frame
mali_list$voisins
# Donc, on a l'embarra du choix.
knitr::asis_output("\\normalsize")
```

### Listes, un contenant de contenants (3)

```{r, echo=c(-1, -13)}
knitr::asis_output("\\tiny")
# Maitenant qu'on peut accéder aux objets à l'intérieur d'un liste,
# qu'en est-il des éléments stockés à l'intérieur de cet objet lui-même.
# Cherchons le 2ème élément du vecteur des pays voisins
mali_list[["voisins"]][2]
# Qu'en est-il de "mali_list[[2]]" et de "mali_list$voisins[2]"?
# Testez avec eux pour voir.

# Un autre exemple: la 3ème colonne de la matrice sur la population
mali_list[["population"]][, 3]
# La ligne suivante aussi marche
mali_list[["population"]][, "Total"]
knitr::asis_output("\\normalsize")
```



## Conclusion

### Et ce n'est que le début

Avec une introduction à ces objets, on pose les bases de l'analyse de données dans R.
Bien que, pour des raisons pédagogiques, chaque objet ait été présenté par rapport aux limites du précédent, ils demeurent tous utiles, chacun avec ses avantages (compétitifs).
Il revient au data scientist de connaître quand, où et comment faire intervenir un au lieu des autres.
Contribuer à vous outiller pour faire ces choix - parmi tant d'autres - est l'un des objectifs de ce cours.







